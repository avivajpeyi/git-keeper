
\documentclass[11pt]{article}
\usepackage{bjc}

\begin{document}

\centerline{\Large\bf CSCI 121: Computer Science II}

\vspace{.1in}

\centerline{\large\bf Programming Project: Set}

\vspace{.25in}

\section*{Overview}

The computational goal of this project is to answer the following questions:

\begin{itemize}
\item What is the average number of sets in a random collection of 12 cards
  from the deck?
\item What is the average number of cards left at the end of the game?
\end{itemize}

In addition to exploring this issue, this project will also give you a chance
to utilize important computer science concepts: abstraction, encapsulation,
array and linked list processing, and object-based programming.

\section*{Class Descriptions}

To answer our questions, we will need four fundamental classes:

\begin{itemize}
\item {\tt Card} represents a single Set card.
\item {\tt Deck} represents the collection of Set cards that have not yet been
  played.
\item {\tt Table} represents the cards currently in play.
\item {\tt Game} encapsulates the rules of the game and coordinates the actions
  of the other objects.
\end{itemize}

\subsection*{Card}

\begin{tabular}{|l|}
\hline
Card \\
\hline
quantity: int \\
color: int \\
shading: int \\
shape: int \\
\hline
Card(int, int, int, int) \\
getQuantity(): int \\
getColor(): int \\
getShading(): int \\
getShape(): int\\
isSet(Card, Card): boolean\\
toString(): String \\
equals(Object): boolean\\
\hline
\end{tabular}

\begin{itemize}
\item Quantities obviously map easily to integer values.  For the other
  attributes, we will use the following conventions throughout the program:

\begin{minipage}{2in}
{\bf Color}\\
1 -- Red\\
2 -- Green\\
3 -- Purple
\end{minipage}
\begin{minipage}{2in}
{\bf Shading}\\
1 -- Open\\
2 -- Striped\\
3 -- Solid
\end{minipage}
\begin{minipage}{2in}
{\bf Shape}\\
1 -- Ovals\\
2 -- Diamonds\\
3 -- Squiggles
\end{minipage}

\item Note that this class is {\em immutable} -- once the data members are set
  by the constructor, they cannot be changed.

\item The order of the parameters to the constructor should be quantity, color,
  shading, shape.  In the constructor, you must ensure that all values are
  between 1 and 3.  If they are not, you should convert the value using
  modulus math.

  If you compute {\tt n \% 3} for a positive integer {\tt n} you will get a
  number between 0 and 2, so you will need to add 1 to the result. For example,
  if a user passes 6 as the parameter for shading, you should set the shading
  to {\tt 6 \% 3 + 1}, which gives you 1.

  Using negative numbers in modular arithmetic in Java does not yield the
  mathematically desireable result. If {\tt n} is negative, you can get the
  correct result this way: 

  {\tt (((n \% 3) + 3) \% 3)}.

\item The various {\tt get} methods simply return the value of that field.

\item The {\tt isSet} method is used to determine if a card forms a set with
  the two parameters.  For example, if {\tt card1}, {\tt card2}, and {\tt
    card3} are all references to objects of type {\tt Card}, then {\tt
    card1.isSet(card2, card3)} will evaluate to true if the three cards form a
  set.

  Recall that three cards form a set if, for each attribute, they are all the
  same or all different.  For example, with quantity, if we have 3 cards with a
  single shape, then their quantities are the same. Note that the legal ways to
  have a set (only considering quantity) are:

\begin{itemize}
\item Each card contains a single shape.  Then, $1 + 1 + 1 = 3$ and
  $3 \mod 3 = 0$
\item Each card contains two shapes.  Then, $2 + 2 + 2 = 6$ and $6 \mod 3 = 0$
\item Each card contains three shapes.  Then, $3 + 3 + 3 = 9$ and $9 \mod 3 = 0$
\item Each card contains a different quantity.  Then, $1 + 2 + 3 = 6$ and
  $6 \mod 3 = 0$
\end{itemize}

In other words, we can determine whether the quantities on three cards
contribute to a legal set by adding them and looking at the result mod 3.
Because we are representing the other attributes with integers in the same
range, this ``trick'' works for the other three attributes as well.

\item The {\tt toString} method is a convenience.  In Java, if you implement
  this method, then you can use {\tt System.out.println} directly on an
  instance of the class.  For instance, the following is legal for this class:

{\footnotesize
\begin{verbatim}
Card c = new Card(1, 2, 3, 1);
System.out.println(c);
\end{verbatim}}

  It is a good idea to keep the resulting string as short as possible so that
  it doesn't take up too much space in the console.  For this class, the
  resulting string should be 4 characters long: the quantity as 1, 2, or 3; the
  color as R, G, or P; the shading as O, T, or S (Note T is striped and S is
  solid); and the shape as O, D, or S.  In the code example above, the
  resulting string would be 1GSO.

\item There is some ``magic'' behind the {\tt equals} method that we will learn
  later in the semester.  In particular, it is not clear why the parameter to
  the method is of type {\tt Object}.  For now, I will simply give you an
  implementation of this method:

{\footnotesize
\begin{verbatim}
public boolean equals(Object obj)
{
  Card that = (Card)obj;
    
  return quantity == that.getQuantity() &&
    color == that.getColor() &&
    shading == that.getShading() &&
    shape == that.getShape();
}
\end{verbatim}}

  With this method in place, you can call {\tt assertEquals} on two objects of
  type {\tt Card}, which will be useful when testing the other classes:

{\footnotesize
\begin{verbatim}
Card c1 = new Card(1, 1, 1, 1);
Card c2 = new Card(1, 1, 1, 1);
assertEquals(c1, c2);
\end{verbatim}}
\end{itemize}

\subsection*{Deck}

\begin{tabular}{|l|}
\hline
Deck \\
\hline
cards: ArrayList \textless Card \textgreater \\
nextCardIndex: int\\
\hline
Deck()\\
Deck(String)\\
hasNext(): boolean \\
getNext(): Card\\
\hline
\end{tabular}

\begin{itemize}
\item This design intends that cards are added to the {\tt cards} {\tt
    ArrayList} at creation but never removed.  To keep track of which cards
  have been ``taken'' from the deck, we use the integer value {\tt
    nextCardIndex}.  If this variable holds 15, that means that the cards in
  indexes 0 through 14 have already been taken from the deck, and the card at
  the ``top'' of the deck is at index 15.

\item The zero-parameter constructor should create the complete deck of 81
  cards and shuffle it.  To shuffle the cards, use:

{\footnotesize
\begin{verbatim} 
// This goes at the top of the file
import java.util.Collections;

// This goes in the constructor
Collections.shuffle(cards);
\end{verbatim}}

\item The constructor that takes a string as its parameter allows the user to
  create a deck from a text file which contains a pre-defined collection of
  cards in a specified order. The string passed to the constructor is the
  filename of the text file to read.

  This is very useful for testing the {\tt Deck} class as well as both the {\tt
    Game} and {\tt Table} classes.  The code for this constructor is complex
  enough that I will simply provide it.  The format for a deck file is
  demonstrated below:

\newpage 
{\footnotesize
\begin{verbatim}
# Lines starting with a # character are comments, and ignored
# Blank lines are also ignored, even if they contain whitespace
   
# All other lines are expected to have 4 integers, separated by spaces
1 1 1 1
1 1 1 2
1 1 1 3

# A file does not need to contain all 81 cards
\end{verbatim}}

  If the above file is named {\tt 3cards.dat} and is contained in the same
  directory as your {\tt .java} files, then you can create a deck based on this
  file:

{\footnotesize\tt Deck d = new Deck(``3cards.dat'');}

\item {\tt hasNext} and {\tt getNext} methods allow the user to conveniently
  obtain all the cards from the deck in order.  For example, we could easily
  print the cards to the console:

{\footnotesize
\begin{verbatim}
Deck d = new Deck()
while(d.hasNext())
{
  Card c = d.getNext();
  System.out.println(c);
}
\end{verbatim}}

  When implementing these methods, you should not assume that the deck contains
  81 cards.  When a {\tt Deck} object is created from a file, the deck can
  contain a variable number of cards. The {\tt size} method of {\tt ArrayList}
  will tell you how many objects it currently holds.

  If the user calls {\tt getNext} when there are no cards left, your method
  should return {\tt null}.

\end{itemize}

\subsection*{Table}

\begin{tabular}{|l|}
\hline
Table \\
\hline
head: TableNode\\
\hline
Table() \\
add(Card): void \\
removeSet(Card, Card, Card): void \\
numCards(): int \\
getCard(int): Card \\
numSets(): int \\
\hline
\end{tabular}
\hspace{.5in}
\begin{tabular}{|l|}
\hline
TableNode \\
\hline
card: Card\\
next: TableNode\\
\hline
TableNode(Card)\\
setNext(TableNode): void\\
getNext(): TableNode\\
getCard(): Card\\
\hline
\end{tabular}

\begin{itemize}
\item The table will be implemented as a linked list made up of nodes of type
  {\tt TableNode}.

\item When adding a card to the table, it should be added to the front of the
  list (head insert).

\item When removing a set, the remaining cards should keep the same relative
  order.  If the three parameters do not form a set or if any of the three
  cards are not currently on the table, then this method should return {\em
    without} removing any cards.

\item The integer parameter to the {\tt getCard} method represents the
  ``index'' of the desired card.  Like an array, the first card is at index 0,
  and if there are $n$ cards on the table then the last card is at index $n-1$.

\item {\tt numSets} and {\tt removeSet} are both challenging to implement.  You
  need to plan carefully how you will approach these methods, and I encourage
  you to draw many pictures to see all the various cases.  In my implementation
  of {\tt removeSet}, I utilized a number of private helper methods to
  functionally decompose the problem.

\item The {\tt TableNode} class represents a node in the linked list.  The
  constructor should set the card to the given parameter and the {\tt next}
  field to {\tt null}.

\item The {\tt next} field can be mutated or queried, allowing you to change
  and traverse a linked list.  The field holding the card is immutable.
\end{itemize}

\subsection*{Game}

\begin{tabular}{|l|}
\hline
Game \\
\hline
t: Table\\
d: Deck\\
\hline
Game()\\
Game(String)\\
numSets(): int\\
numCards(): int\\
playRound(): void\\
isGameOver(): boolean\\
\hline
\end{tabular}

\begin{itemize}
\item The zero-parameter constructor begins a new game using a randomly
  generated deck.  This means that there are 12 cards on the table when the
  constructor completes.

\item The other constructor takes a filename as its parameter, and this file is
  used to load a specified deck.  Because this deck might contain less than 12
  cards, the number of cards on the table when the constructor returns is
  either 12 or the number of cards in the deck, whichever is smaller.

\item For our study, we need the {\tt numSets} and {\tt numCards} query
  methods, which return information about the current table.

\item In general, a round deals with removing one set and adding additional
  cards.  To define this concept carefully, consider the following situations:

\begin{itemize}
\item Occasionally there are no sets on the table, but still cards in the deck.
  In this case moving from one round to the next means that we simply add three
  cards.
\item In the majority of situations, there are cards in the deck and 12 cards
  on the table containing one or more sets.  In this case, we move from one
  round to the next by removing one set and adding three cards to the table
  from the deck.
\item If a round starts with more than 12 cards on the table (because a
  previous round had no sets), and there is at least one set on the table, then
  after removing a set we do not add more cards.
\item If there is at least one set on the table but no cards remaining in the
  deck, then we move from one round to the next by removing a set from the
  table.
\item If there are no cards in the deck and no sets on the table, it is not
  possible to move to a new round.  The game is over.
\end{itemize}

When using custom decks, it is possible that there are only 1 or 2 cards
remaining when it is time to add cards to the table.  In such a situation,
these cards are added, and the table is 1 or 2 cards ``short'' from what would
normally occur.

Given the above definition, the purpose of {\tt playRound} is to advance the
game from one round to the next.

\item As described above, {\tt isGameOver} is true only if there are no sets on
  the table and no cards in the deck.
\end{itemize}

\section*{Monte Carlo Simulation}

Using these classes, we can now answer our two questions.  Our technique will
be Monte Carlo simulation -- we will run a large number of independent
experiments and then take the average of these experiments.  This number is an
estimate of the quantity measured.  As you might expect, the more experiments
run, the better the estimate.

When considering collections of 12 cards, one experiment is defined to be
taking 12 random cards from a deck and counting how many sets are contained in
that collection.  To keep the experiments independent, it is important that
each experiment uses a {\em different} deck -- it is not appropriate to take
additional cards from the same deck as a previous experiment.

For the second question, one experiment is one game played with a random deck.
When the game is over, you simply look at the number of cards on the table.

Unlike the other parts of the project, I do not have any formal guidelines of
how to implement these experiments and data collection.  I encourage you to
develop a {\tt Main} class that runs the experiment, but you may decide how to
coordinate the actions of the relevant objects.

\section*{Final Write-Up}

Your final write-up will be approximately 1 to 2 single-spaced pages.  About
half of your write-up should describe your experiments and the results you
gathered.  The other half should be a reflection on the project. Write about
what you learned by doing a coding project of this scale.  In particular, what
would you do differently if you had to do it again? What will you do
differently on future projects?

\section*{Submitting}

The two methods I have provided for you (the {\tt equals} method for {\tt Card}
and one of the constructors for {\tt Deck}) are in the appropriate Java files
in the SetProject repository on GitHub. Fork and clone this repository and put
all your Java files in the {\tt src/} directory. As you work, commit to the
repository regularly so you have a history of your work. When you commit, push
to GitHub so you have a backup of your work too. To grade your work I will
access your code from GitHub. You may submit your write-up through email,
google drive, or as a markdown file in your project repository.

\section*{Due Dates}

The four main classes of this project will be evaluated individually according
to the following schedule. The final submission will be the complete program
plus a write-up of the results of the experiments. Make sure you have committed
and pushed the necessary files to GitHub by the due dates.

\begin{itemize}
\item Wednesday, April 1 -- {\tt Card.java} and {\tt CardTest.java}
\item Wednesday, April 8 -- {\tt Deck.java} and {\tt DeckTest.java}
\item Wednesday, April 15 -- {\tt Table.java}, {\tt TableTest.java}, {\tt
    TableNode.java}, and {\tt TableNodeTest.java}
\item Wednesday, April 22 -- {\tt Game.java} and {\tt GameTest.java}
\item Wednesday, April 29 -- all code and your final write-up.
\end{itemize}

\section*{Grading}

For each due date, I will run JUnit tests on your code. For this to work, it is
necessary that the interface of each class {\em exactly} matches the
specifications in this document.

Half of the grade for this project will be based on how many of my tests pass
on each of the first 4 due dates. After each due date I will share my test code
with you so that you can make sure your classes are working correctly before
you move on.

The other half of the grade will be based on the final code submission and the
write-up.

\section*{Helping Each Other}

You are bound to run into hurdles during this project, and I encourage you to
talk to your classmates if you are stuck and need help. However, this is NOT a
group project and as such you should not share your code with others. Help each
other with concepts, but write your own code. Submitting copied code (which
includes taking someone's code and changing around variable names to make it
look different) will not be tolerated and will be considered a violation of
Moravian's academic honesty policy.

\section*{Hints and Suggestions}

\begin{itemize}
\item Because the {\tt Card} class is immutable, it is the easiest to test.
  The most challenging part of this class is making sure that the values are
  assigned correctly when values outside the range 1 to 3 are passed as
  arguments to the constructor.  Be sure to test this extensively.  Also, don't
  forget to test the {\tt toString} method.

\item When testing a method that returns a boolean, you can use Junit's other
  methods, {\tt assertTrue} and {\tt assertFalse}.

\item The {\tt Game} needs a {\tt Table} and a {\tt Deck}, and both of these
  classes rely on the {\tt Card} class.  These dependencies imply that you
  should implement {\tt Card} first.  {\em Do not} continue to other classes
  until you are confident that the {\tt Card} class is working -- i.e. that all
  your (extensive) tests pass.

\item I think that {\tt Table} is the ``hardest'' class to implement because it
  contains a linked list.

\item I have worked hard to make these specifications accurate, consistent, and
  complete -- but if you find a place that fails to meet these ideals, send me
  email, and I will clarify.

\item Do not attempt to complete the parts of this project the night before
  their deadlines.  You should work on this project a little bit every day.

\item You should attempt to solve problems on your own first, but spending
  hours finding subtle errors is frustrating and counter-productive.  Email me
  or come talk to me if you are stuck.

\item Working code is important, but if you suspect your code is ``ugly,'' you
  should work to make it better.  Ultimately, this will be a portion of your
  final grade for the project.

\item Sometimes when a test fails, it is hard to tell exactly what went wrong
  because Junit ``hides'' some errors.  If you find this is the case, copy the
  code for the test (minus the calls to {\tt assertEquals} into a class
  containing a {\tt main} method.  When you run the code this way, you will see
  the details of the error.

\item This document contains {\em many} details, and you could not possibly
  absorb them all on a single reading.  I encourage you to return to it
  frequently as you progress -- both to better understand the specifications
  and to garner additional hints.
\end{itemize}
\end{document}

